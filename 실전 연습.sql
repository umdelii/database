-- 1. 사원번호가 176인 사원의 LAST_NAME, 부서번호 정보 조회
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	e.EMPLOYEE_ID = 176;

-- 2. 급여가 12000 이상 되는 직원들의 LAST_NAME, 급여 조회
SELECT
	LAST_NAME ,
	SALARY
FROM
	EMPLOYEES e
WHERE
	e.SALARY >= 12000;

-- 3. 연봉이 5000 ~ 12000 범위가 아닌 사람들의 LAST_NAME, 급여 조회
SELECT
	e.LAST_NAME ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	(e.SALARY * 12)<5000
	OR (e.SALARY * 12)>12000;

-- 4. 20번, 50번 부서에 근무하는 사원들의 LAST_NAME, 부서번호를 오름차순으로 조회
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	e.DEPARTMENT_ID IN (20, 50)
ORDER BY
	e.DEPARTMENT_ID ASC,
	e.LAST_NAME ASC;

-- 5. 커미션을 받는 모든 사원들의 LAST_NAME, 급여, 커미션을 조회 / 급여 & 커미션 내림차순 조회
SELECT
	e.LAST_NAME,
	e.SALARY ,
	e.COMMISSION_PCT
FROM
	EMPLOYEES e
WHERE
	e.COMMISSION_PCT > 0
ORDER BY
	e.SALARY DESC,
	e.COMMISSION_PCT DESC; 

-- 6. 연봉이 2500, 3500, 7000이 아니며, 직무가 SA_REP, ST_CLERK 인 사원조회
SELECT
	*
FROM
	EMPLOYEES e
WHERE
	(e.SALARY * 12)NOT IN(2500, 3500, 7000)
	AND e.JOB_ID IN ('SA_REP', 'ST_CLERK');

-- 7. 2015/02/20 ~ 2015/05/01 사이에 고용된 사원들의 LAST_NAME, 사번, 고용일자 조회
-- 고용일자 내림차순
SELECT
	e.LAST_NAME ,
	e.EMPLOYEE_ID ,
	e.HIRE_DATE
FROM
	EMPLOYEES e
WHERE
	e.HIRE_DATE BETWEEN '2015-02-20' AND '2015-05-01'
ORDER BY
	e.HIRE_DATE DESC;

-- 8. 20번, 50번 부서에 근무하는 사원들 중 연봉이 5000이상 12000이하는 사원의 LAST_NAME, 급여 조회 / 급여의 오름차순 정렬
SELECT
	e.LAST_NAME ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	e.DEPARTMENT_ID IN (20, 50)
	AND (e.SALARY * 12) BETWEEN 5000 AND 12000
ORDER BY
	e.SALARY ASC;

-- 9. 연봉이 5000 ~ 12000이 아닌 사원들의 LAST_NAME, 급여 조회 / 급여의 오름차순 정렬
SELECT
	e.LAST_NAME ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	e.SALARY NOT BETWEEN 5000 AND 12000
ORDER BY
	e.SALARY ASC;

-- LIKE
-- 10. LAST_NAME에 u가 포합되는 사원들의 사번, LAST_NAME 조회
SELECT
	e.LAST_NAME,
	e.EMPLOYEE_ID
FROM
	EMPLOYEES e
WHERE
	e.LAST_NAME LIKE '%u%';

-- 11. LAST_NAME에 4번째 글자가 a인 사원들의 LAST_NAME 조회
SELECT
	e.LAST_NAME
FROM
	EMPLOYEES e
WHERE
	e.LAST_NAME LIKE '___a%';

-- 12. LAST_NAME에 a 혹은 e 글자가 있는 사원들의 LAST_NAME 조회, LAST_NAME 오름차순
SELECT
	e.LAST_NAME
FROM
	EMPLOYEES e
WHERE
	e.LAST_NAME LIKE '%a%'
	OR e.LAST_NAME LIKE '%e%'
ORDER BY e.LAST_NAME ASC;

-- 13. LAST_NAME에 a와 e 글자가 포함된 사원들의 LAST_NAME을 조회하여 LAST_NAME으로 오름차순
SELECT
	e.LAST_NAME
FROM
	EMPLOYEES e
WHERE
	e.LAST_NAME LIKE '%a%'
	AND e.LAST_NAME LIKE '%e%'
ORDER BY
	e.LAST_NAME ASC;
-- 강사님 답
SELECT
	e.LAST_NAME
FROM
	EMPLOYEES e
WHERE
	e.LAST_NAME LIKE '%a%e%'
	OR e.LAST_NAME LIKE '%e%a%'
ORDER BY
	e.LAST_NAME ASC;

-- is NULL
-- 14. MANAGER ID가 없는 사원들의 LAST_NAME, JOB_ID 조회
SELECT
	e.LAST_NAME ,
	e.JOB_ID
FROM
	EMPLOYEES e
WHERE
	e.MANAGER_ID IS NULL;

-- 15. 직무가 ST_CLERK인 사원이 근무하고 있지 않은 부서 ID 조회
--		단, 부서번호가 NULL인 것은 제외
SELECT
	DISTINCT e.DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	e.JOB_ID NOT IN ('ST_CLERK')
	AND e.DEPARTMENT_ID IS NOT NULL;

-- 16. COMMISSION_PCT가 NULL이 아닌 사원들 중 COMMISSION = SALARY * COMMISSION_PCT를 구하여 사번, FIRST_NAME, JOB_ID 조회
SELECT
	e.EMPLOYEE_ID ,
	e.FIRST_NAME ,
	e.JOB_ID,
	SALARY * COMMISSION_PCT AS COMMISSION
FROM
	EMPLOYEES e
WHERE
	e.COMMISSION_PCT IS NOT NULL;

-- 함수
-- 17. FIRST_NAME이 Curtis인 사람의 FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, JOB_ID 조회
--     단 JOB_ID는 소문자로 출력
SELECT
	e.FIRST_NAME ,
	e.LAST_NAME ,
	e.EMAIL ,
	e.PHONE_NUMBER ,
	LOWER(e.JOB_ID)
FROM
	EMPLOYEES e
WHERE
	e.FIRST_NAME = 'Curtis';

-- 18. 부서번호가 60, 70, 80, 90인 사원들의 사원번호, FIRST_NAME, HIRE_DATE, JOB_ID 조회 
--     단, JOB_ID가 IT_PROG인 사원의 경우 프로그래머로 변경하여 출력
SELECT
	e.EMPLOYEE_ID ,
	e.FIRST_NAME ,
	e.HIRE_DATE ,
	REPLACE(e.JOB_ID, 'IT_PROG', '프로그래머')
FROM
	EMPLOYEES e
WHERE
	e.DEPARTMENT_ID IN (60, 70, 80, 90);

-- 19. JOB_ID가 AD_PRES, PU_CLERK인 사원들의 사원번호, FIRST_NAME, LAST_NAME, 부서번호, JOB_ID 조회
--     단, 사원명은 FIST_NAME과 LAST_NAME을 연결하여 출력하시오
SELECT
	e.EMPLOYEE_ID ,
	e.FIRST_NAME || ' ' || e.LAST_NAME,
	e.DEPARTMENT_ID ,
	e.JOB_ID
FROM
	EMPLOYEES e
WHERE
	e.JOB_ID IN ('AD_PRES', 'PU_CLERK');

-- 다중행함수
-- 20. 회사 내의 최대연봉 및 최소연봉의 차이를 조회
-- SAL_GAP
SELECT
	MAX(e.SALARY),
	MIN(e.SALARY),
	(MAX(e.SALARY)-MIN(e.SALARY)) AS SAL_GAP
FROM
	EMPLOYEES e ;

-- 21. 매니저로 근무하는 사원들의 총 숫자는?
SELECT
	COUNT(DISTINCT e.MANAGER_ID) AS "매니저 수"
FROM
	EMPLOYEES e
WHERE
	e.MANAGER_ID IS NOT NULL
	
-- 22. 매니저가 없는 사원들은 제외하고 매니저가 관리하는 사원들 중 최소급여를 받는 사원 조회
--     단, 매니저가 관리하는 사원 중 급여가 6000미만인 사원은 제외
--     매니저아이디, 최소급여 출력
SELECT
	e.MANAGER_ID,
	MIN(e.SALARY) AS MIN_SAL_OR_MORE_6000
FROM
	EMPLOYEES e
WHERE
	e.MANAGER_ID IS NOT NULL
GROUP BY
	e.MANAGER_ID
HAVING
	MIN(e.SALARY) >= 6000
ORDER BY
	e.MANAGER_ID;

-- JOIN
-- 23. 자신의 담당 매니저의 고용일보다 빠른 입사자 찾기
-- EMPLOYEES SELF JOIN
SELECT 
	e2.EMPLOYEE_ID ,
	e.LAST_NAME,
	e.HIRE_DATE ,
	e.MANAGER_ID,
	e2.LAST_NAME,
	e2.HIRE_DATE
FROM
	EMPLOYEES e
JOIN EMPLOYEES e2 ON
	e.MANAGER_ID = e2.EMPLOYEE_ID
WHERE
	e.HIRE_DATE < e2.HIRE_DATE ; 

-- 24. 도시 이름이 T로 시작하는 지역에 사는 사원들의 사번, LAST_NAME, 부서번호 조회
-- EMPLOYEES, DEPARTMENTS, LOCATIONS
SELECT
	e.EMPLOYEE_ID ,
	e.LAST_NAME ,
	e.DEPARTMENT_ID,
	l.CITY
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l ON
	d.LOCATION_ID = l.LOCATION_ID
WHERE
	UPPER(l.CITY) LIKE 'T%'
ORDER BY
	e.EMPLOYEE_ID;

-- 25. 위치 ID가 1700인 사원들의 사번, LAST_NAME, 부서번호, 급여 조회
-- EMPLOYEES, DEPARTMENTS
SELECT
	e.EMPLOYEE_ID ,
	e.LAST_NAME ,
	e.DEPARTMENT_ID ,
	e.SALARY
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE
	d.LOCATION_ID = 1700
ORDER BY
	e.EMPLOYEE_ID ;

-- 26. 부서명, 위치ID, 각 부서별 사원총수, 부서별 평균 급여 조회(평균 연봉은 소수점 두자리까지 표기)
-- EMPLOYEES, DEPARTMENTS
SELECT
	d.DEPARTMENT_NAME ,
	e.DEPARTMENT_ID ,
	d.LOCATION_ID ,
	COUNT(*),
	ROUND(AVG(e.SALARY), 2)
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY
	e.DEPARTMENT_ID,
	d.DEPARTMENT_NAME ,
	d.LOCATION_ID
ORDER BY
	e.DEPARTMENT_ID ;

-- 27. Executive부서에 근무하는 모든 사원들의 LAST_NAME, 부서번호, 부서명, JOB_ID 조회
-- EMPLOYEES, DEPARTMENTS
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID ,
	d.DEPARTMENT_NAME ,
	e.JOB_ID
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE
	d.DEPARTMENT_NAME = 'Executive'
ORDER BY
	d.DEPARTMENT_ID ;

-- 28. 각 사원별 소속부서에서 자신보다 늦게 고용되었으나 급여가 더 많은 사원이 존재하는 모든 사원들의 이름 조회
--     이름은 FIRST_NAME, LAST_NAME을 연결하여 출력
-- EMPLOYEES SELF JOIN
SELECT
	DISTINCT e.EMPLOYEE_ID ,
	e.FIRST_NAME || ' ' || e.LAST_NAME AS NAME
FROM
	EMPLOYEES e
JOIN EMPLOYEES e2 ON
	e.DEPARTMENT_ID = e2.DEPARTMENT_ID
WHERE
	e.HIRE_DATE < e2.HIRE_DATE
	AND
	e.SALARY < e2.SALARY
ORDER BY
	e.EMPLOYEE_ID ;

-- SUBQUERY
-- 29. JOB_ID가 'SA_MAN'인 사원들의 최대 급여보다 높게 받는 사원들의 LAST_NAME, JOB_ID, SALARY 조회
SELECT
	e.LAST_NAME ,
	e.JOB_ID ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	e.SALARY > (
	SELECT
		MAX(e2.SALARY)
	FROM
		EMPLOYEES e2
	WHERE
		e2.JOB_ID = 'SA_MAN'); 

-- 30. 커미션을 받는 사원들의 부서와 급여가 동일한 사원들의 LAST_NAME, 부서번호, 급여 조회
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	(e.DEPARTMENT_ID,
	e.SALARY) IN (
	SELECT
		e2.DEPARTMENT_ID ,
		e2.SALARY 
	FROM
		EMPLOYEES e2
	WHERE
		e2.COMMISSION_PCT IS NOT NULL); 

-- 31. 회사 전체 평균 급여보다 급여가 높은 사원 중 LAST_NAME에 'u'가 들어있는 사원들이 근무하는 부서에서
-- 	   근무하는 사원들의 사번, LAST_NAME, SALARY 조회
-- 	   단, 평균 급여는 반올림한 후 비교
SELECT
	e3.EMPLOYEE_ID ,
	e3.LAST_NAME ,
	e3.SALARY
FROM
	EMPLOYEES e3
WHERE
	e3.DEPARTMENT_ID IN (
	SELECT
		e.DEPARTMENT_ID
	FROM
		EMPLOYEES e
	WHERE
		e.SALARY > (
		SELECT
			ROUND(AVG(e2.SALARY), 0)
		FROM
			EMPLOYEES e2)
		AND LOWER(e.LAST_NAME) LIKE '%u%');
		
-- 32. 위치 ID가 1700인 사원들의 급여, 커미션 추출 뒤, 추출된 사원들의 급여와 커미션이 동일한 사원정보 출력
-- 	   사번, 이름(FIRST_NAME + LAST_NAME), 부서번호, 급여
SELECT
	e.EMPLOYEE_ID ,
	e.FIRST_NAME || ' ' || e.LAST_NAME AS NAME,
	e.DEPARTMENT_ID ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	(e.SALARY,
	NVL(e.COMMISSION_PCT, 0) ) IN (
	SELECT
		e2.SALARY ,
		NVL(e2.COMMISSION_PCT , 0)
	FROM
		EMPLOYEES e2
	JOIN DEPARTMENTS d ON
		e2.DEPARTMENT_ID = d.DEPARTMENT_ID
	WHERE
		d.LOCATION_ID = 1700 );

-- 33. 총 사원 수 및 2011,2012,2013,2014년도 별 고용된 사원들의 사원수 조회
-- SELECT절에 사용하는 서브쿼리로 작성
SELECT
	DISTINCT (
	SELECT
		COUNT(*)
	FROM
		EMPLOYEES e) AS ALL_EMP,
	(
	SELECT
		COUNT(*)
	FROM
		EMPLOYEES e2
	WHERE
		TO_CHAR(e2.HIRE_DATE, 'YYYY') = '2011') AS "2011_HIRE",
	(
	SELECT
		COUNT(*)
	FROM
		EMPLOYEES e3
	WHERE
		TO_CHAR(e3.HIRE_DATE, 'YYYY') = '2012') AS "2012_HIRE",
	(
	SELECT
		COUNT(*)
	FROM
		EMPLOYEES e4
	WHERE
		TO_CHAR(e4.HIRE_DATE, 'YYYY') = '2013') AS "2013_HIRE",
	(
	SELECT
		COUNT(*)
	FROM
		EMPLOYEES e5
	WHERE
		TO_CHAR(e5.HIRE_DATE, 'YYYY') = '2014') AS "2014_HIRE"
FROM
	EMPLOYEES e ;